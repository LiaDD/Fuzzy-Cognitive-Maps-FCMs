{
    "collab_server" : "",
    "contents" : "#' @title Fuzzy Cognitive Maps (FCMs) Inference\n#' @description Estimates the Inference of a Fuzzy Cognitive Map.  FCM is proven to be capable of causal inference and is applicable to complex decision problems where numerous interlinked dependent variables influence one another.\n#'\n#' @param activation_vec 1 x m dataframe which contains the initial concept values. A concept is turned on or activated by making its vector element 1 or 0 or in [0, 1].\n#' @param weight_mat m x m dataframe which stores the weights assigned to the pairs of concepts. The weights are usually normalized to the interval [0, 1] or [−1, +1].\n#' @param iter The required number of iterations in order to reach the FCM convergence. Defaults to 20.\n#' @param infer Select an Inference Rule ('k' Kosko, 'mk' modified Kosko, 'r' Rescale,'kc' Kosko-clamped, 'mkc' modified Kosko-clamped or 'rc' Rescale-clamped). Default value is set to 'k'\n#' @param transform Contains the Transformation functions ('b' Bivalent,  'tr' Trivalent,  's' Sigmoid or 't' Hyperbolic tangent). The transformation function is used to reduce unbounded weighted sum to a certain range, which hinders quantitative analysis, but allows for qualitative comparisons between concepts. Default value is set equal to 's'.\n#' @param lambda A parameter that determines the steepness of the sigmoid and hyperbolic tangent function at values around 0. Different lambda value may perform more appropriate for different problems.\n#' @param e Epsilon (e) is a residual, describing the minimum error difference among the subsequent concepts. Its value depends on the application type. Defaults to to 0.001.\n#'\n#' @return Returns iter x m dataframe which contains the concepts' values of each iteration after the the transformation function.\n#' @export\n#' @author Zoumpolia Dikopoulou <dikopoulia@gmail.com>, <zoumpolia.dikopoulou@uhasselt.be>\n#' @author Elpiniki Papageorgiou <epapageorgiou@teiste.gr>, <e.i.papageorgiou75@gmail.com>\n#'\n#' @references B. Kosko, \"Fuzzy cognitive maps\", International Journal of Man-Machine Studies 24, p.p. 65-75, 1986.\n#' @references Groumpos, P.P, Stylios, C.D.; \"Modelling supervisory control systems using fuzzy cognitive maps\", Chaos, Solitons & Fractals, Volume 11, Issues 1–3, p.p. 329–336, 2000.\n#' @references Papageorgiou E.I., \"Fuzzy Cognitive Maps for Applied Sciences and Engineering From Fundamentals to Extensions and Learning Algorithms\", Intelligent Systems Reference Library, Volume 54, 2014.\n#' @references Papageorgiou E.I., Stylios C.D., GroumposP.P. , \"Unsupervised learning techniques for finetuning fuzzy cognitive map causal links.\", Int. J. Human Comput. Stud. Vol. 64, pp. 727–743, 2006.\n#' @examples \\dontrun{\n#' # Example for the FCM inference\n#'\n#'\n#' ### Input data\n#'\n#' act.vec <- data.frame(1, 1, 1, 0, 0, 0)    # Create the activation vector\n#' colnames(act.vec) <- c(\"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\")  # Change the column names\n#'\n#' C1 = c(0.0, 0.0, 0.6, 0.9, 0.0, 0.0)\n#' C2 = c(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n#' C3 = c(0.0, 0.7, 0.0, 0.0, 0.9, 0.0)\n#' C4 = c(0.0, 0.0, 0.0, 0.0, 0.0, 0.9)\n#' C5 = c(0.0, 0.0, 0.0, 0.0, 0.0, -0.9)\n#' C6 = c(-0.3, 0.0, 0.0, 0.0, 0.0, 0.0)\n#' C7 = c(0.0, 0.0, 0.0, 0.0, 0.0, 0.8)\n#'\n#' # Create the weight matrix\n#' w.mat <- matrix(c(C1, C2, C3, C4, C5, C6, C7), nrow = 6, ncol = 6, byrow = TRUE)\n#' colnames(w.mat) <- c(\"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\")\n#' w.mat <- as.data.frame(w.mat)\n#'\n#'\n#'\n#' ### Select the arguments for the fcm.infer function\n#'\n#' output <- fcm.infer(act.vec, w.mat, 25, \"r\", \"s\")\n#' View(output$values)          # View the concept values for each iteration\n#'\n#'\n#' ### Visualize the concepts' values for each state\n#'\n#' library (reshape2)\n#' library (ggplot2)\n#' iterations <- as.numeric(rownames(output$values))  # create a numeric vector named \"iterations\"\n#' df <- data.frame(iterations, output$values)   # add \"iterations\" in the \"output$values\" dataframe\n#' df2 <- melt(df, id=\"iterations\")   #transform df into long formats\n#' ggplot(data=df2,\n#'        aes(x=iterations, y=value, group=variable, colour=variable)) +\n#'        theme_bw() + geom_line(size=0.7) + geom_point(size = 3)\n#'\n#' }\n\n\n\n  fcm.infer <- function (activation_vec, weight_mat, iter = 20, infer = 'k', transform = 's', lambda = 1, e = 0.001) {\n\n\n\n    # ------------------------------------------ checks on function input ------------------------------------------------------------------------------------ #\n\n    # Check the values of the activation vector\n    if (length(which(activation_vec > 1)) & length(which(activation_vec > -1))) {\n      stop (\"Please check the concepts' values of the activation vector. They must be in the range -1 and 1.\")\n    }\n\n\n    # Check the weights of the matrix\n    if (length(which(weight_mat > 1)) & length(which(weight_mat > -1)) ) {\n      stop (\"Please check the weights of the matrix. They must be in the range -1 and 1.\")\n    }\n\n\n    # Check for missing values\n    if (sum(is.na(activation_vec)) > 0) {\n      stop (\"Please check the activation vector for missing values.\")\n    }\n\n\n    if (sum(is.na(weight_mat)) > 0) {\n      stop (\"Please check the weight matrix for missing values.\")\n    }\n\n\n    # Check the variable of the transformation function\n    if(iter <= 0 ) stop (\"The iterations must be higher than zero.\")\n\n\n    # Check the variable of the Inference Rule\n    if(sum(!(infer %in% c('k', 'mk', 'r', 'kc', 'mkc', 'rc'))) > 0) stop (\"For the Inference Rule only Kosko 'k', modified Kosko 'mk',  Rescale 'r', Kosko-clamped 'kc', modified Kosko-clamped 'mkc' or Rescale-clamped 'rc' variables are allowed.\")\n\n\n    # Check the variable of the transformation function\n    if(sum(!(transform %in% c('b', 'tr', 's', 't'))) > 0)\n      stop (\"For the transformation functions only Bivalent 'b', Trivalent 'tr', Sigmoid 's' or\n            Hyperbolic tangent 't' variables are allowed.\")\n\n\n    # Check the variable of the lambda value\n    if((lambda <= 0) || (lambda >= 10)) stop (\"Lambda value should be in the range 1 to 10.\")\n\n\n    # Check the variable of e parameter\n    if(sum(!(e %in% c(0.01, 0.001, 0.0001, 0.00001, 0.000001))) > 0)\n      stop (\"Select one of the possible e values: 0.01, 0.001, 0.0001, 0.00001 or 0.000001.\")\n\n\n    # ------------------------------------------ Input values ------------------------------------------------------------------------------------ #\n\n\n    m <- ncol(weight_mat)\n\n\n    # ------------------------------------------ Inference Rules  ------------------------------------------------------------------------------------ #\n\n\n    mylist <- list()\n    for(i in 1:(iter-1)) {\n\n      if(i == 1) {\n        if (infer == \"k\" || infer == \"kc\"){\n          initial_vec <- colSums(t(activation_vec) * weight_mat)\n        } else if  (infer == \"mk\" || infer == \"mkc\"){\n          initial_vec <- activation_vec + colSums(t(activation_vec) * weight_mat)\n        } else if (infer == \"r\" || infer == \"rc\"){\n          initial_vec <- (2 * activation_vec - 1) + colSums(t((2 * activation_vec) - 1) * weight_mat)\n        }\n\n        if (transform == \"s\") {\n          initial_vec <- 1/(1+exp(- lambda * initial_vec)) }\n        if (transform == \"t\") {\n          initial_vec <- tanh(lambda * initial_vec)\n        }\n\n      } else {\n        # calculates the new vector (for the second until the last iteration or time step)\n        if (infer == \"k\" || infer == \"kc\"){\n          initial_vec <- colSums(t(initial_vec) * weight_mat)\n        } else if  (infer == \"mk\" || infer == \"mkc\"){\n          initial_vec <- initial_vec + colSums(t(initial_vec) * weight_mat)\n        } else if (infer == \"r\" || infer == \"rc\"){\n          initial_vec <- (2 * initial_vec - 1) + colSums(t((2 * initial_vec) - 1) * weight_mat)\n        }\n\n        if (transform == \"s\") {\n          initial_vec <- 1/(1+exp(- lambda * initial_vec)) }\n        if (transform == \"t\") {\n          initial_vec <- tanh(lambda * initial_vec)\n        }\n      }\n\n      if (transform == \"b\") {\n        for(j in 1:m) {\n          if (initial_vec[j] > 0){\n            initial_vec[j] <- 1\n          } else if (initial_vec[j] <= 0){\n            initial_vec[j] <- 0\n          }\n        }\n      }\n\n      if (transform == \"tr\") {\n        for(j in 1:m) {\n          if (initial_vec[j] > 0){\n            initial_vec[j] <- 1\n          } else if (initial_vec[j] < 0){\n            initial_vec[j] <- - 1\n          } else initial_vec[j] <- 0\n        }\n      }\n\n      if (infer == \"kc\" || infer == \"mkc\" || infer == \"rc\"){\n        for(k in 1:m) {\n          if(activation_vec[k] == 1) {\n            initial_vec[k] <- (initial_vec[k] = 1)\n          }\n        }\n      }\n      mylist[[i]] <- initial_vec     # insert each produced stabilized vector in the list\n\n   }\n\n\n\n    steps_t <- (as.data.frame (do.call(\"rbind\",mylist)))   # transform the produced stabilized vectors into a data frame\n    step_1 <- as.numeric(activation_vec)\n\n    # Insert the activation vector in the first row of the dataframe that contains the stabilized vectors of all time steps\n    A <- (rbind(step_1, steps_t))\n    last_conv <- as.double(A[iter,] - A[(iter-1),])   # check if the steady state has been reached of the last two iterations\n    Res_e <- (length(last_conv[last_conv <= e]))    # Set the residual value (epsillon \"e\") equal to 0.001\n\n\n    if ( Res_e < m)  {\n      cat(\"\\n WARNING: More iterations are required to reach the convergence.\\n \\n\")\n    } else {\n\n      mylist1 <- list()\n      for(i in 2:(iter)){\n        subst <- abs(apply(A, 2, function(x) x[i] - x[i-1]))   # subtraction of \"ith\" - \"(i-1)th\" state\n        mylist1[[i]] <- subst     # Save all subtraction vectors in a list\n      }\n      subst.mat <- do.call(\"rbind\",mylist1)\n\n\n      w <- as.data.frame(matrix(e, (iter - 1), m))    # Create a dataframe [(iterations - 1), m)] of values = epsillon\n\n\n      mylist3 <- list()\n      for(i in 1:(iter-1)){\n        if(all(subst.mat[i,] < w[i,]))    # Check for the converged state\n        {\n          cv <- 1      # The concepts' value (cv) is converged\n        }\n        else {\n          cv <- 2      # The concepts' value is NOT converged\n        }\n        mylist3[[i]] <- cv\n      }\n      cv.mat<-do.call(\"rbind\",mylist3)\n\n\n      conv_state <- min(which(cv.mat == 1))\n      cat(sprintf(\"\\n The concepts' values are converged in %ith state (e <= %f) \\n\", conv_state + 1, e))\n      cat(\"\\n\")\n      print(A[(conv_state + 1),], row.names = FALSE)\n      cat(\"\\n\")\n    }\n\n\n     outlist <- list('values'= A)     # the concepts values in each state\n    return (outlist)\n\n }\n\n",
    "created" : 1495120828805.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1014592352",
    "id" : "B23586D1",
    "lastKnownWriteTime" : 1495538643,
    "last_content_update" : 1495538643294,
    "path" : "~/fcm/R/fcm.infer.R",
    "project_path" : "R/fcm.infer.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}